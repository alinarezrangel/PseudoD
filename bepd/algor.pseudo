[ ******************************************************************************
*****************************************
*********
** algor.pseudo: Algoritmos de utilidad.
** PseudoD fue creado por Alejandro Linarez Rangel
** algor.pseudo fue creado por Alejandro Linarez Rangel
** Puede copiar, redistribuir y modificar este archivo con permiso de
** <proyectopseudod@gmail.com>.
*****************************************
****************************************************************************** ]

utilizar tipos.pseudo
utilizar mate.pseudo
utilizar cadena.pseudo

[DOCUMENTA
@file Documentación de algor.pseudo.
Este archivo posee clases dinamicas, que representan objetos comunes, como
listas, arrays, funciones tipo foreach, arboles binarios, etc.
DOCUMENTA]

[DOCUMENTA
@brief Representa un iterador.
Este puede iterar sobre todos (o algunos) elementos de un determinado
contenedor. Actualmente, esta clase no realiza acción alguna dado que
la lógica de esta debe ser implementada especificamente para la clase
contenedora en la que se vaya a utilizar.

@abstract
DOCUMENTA]
clase Iterador
	:obtenerActual
	:siguiente
finclase
heredar Objeto Iterador

[DOCUMENTA
@brief Obtiene el elemento actual.
@argyo
@dev Referencia común al elemento actual
@races None
DOCUMENTA]
funcion Iterador#obtenerActual
finfun

[DOCUMENTA
@brief Avanza un elemento.
Luego de avanzar, el iterador puede quedar fuera del contenedor, para asegurarse
que esto no pase, compare el iterador con el final del contenedor.

@argyo
@races None
DOCUMENTA]
funcion Iterador#siguiente
finfun

[DOCUMENTA
@brief Iterador bidireccional.
Dado que no todas las estructuras de datos soportan recorridos bidireccionales,
la clase <Iterador> no provee forma de retroceder un elemento.

@abstract
DOCUMENTA]
clase IteradorBidireccional
	:anterior
finclase
heredar Objeto IteradorBidireccional

[DOCUMENTA
@brief Retrocede un elemento.
Luego de retroceder, el iterador puede quedar fuera del contenedor, para
asegurarse que esto no pase, compare el iterador con el inicio del contenedor.

@argyo
@races None
DOCUMENTA]
funcion IteradorBidireccional#anterior
finfun

[DOCUMENTA
@brief Iterador en reversa
Cuando se invoca a <Iterador\#siguiente> en este iterador, en vez de
avanzar un elemento, retrocede uno. El orden de este iterador **siempre**
es contrario a <Iterador>, más **no garantiza** que si <Iterador> pasa
por un determinado elemento, este también pase por dicho.

@abstract
DOCUMENTA]
clase IteradorReversa
finclase
heredar Iterador IteradorReversa

[DOCUMENTA
@brief Iterador bidireccional en reversa
Como IteradorBidireccional, pero implementando IteradorReversa.

Aunque no hereda a IteradorBidireccional, lo implementa.

@abstract
DOCUMENTA]
clase IteradorBidireccionalReversa
	:anterior
finclase
heredar IteradorReversa IteradorBidireccionalReversa

funcion IteradorBidireccionalReversa#anterior
finfun

[DOCUMENTA
@brief Representa un contenedor
Todos los contenedores proveen los iteradores mediante métodos especializados.

@abstract
DOCUMENTA]
clase Contenedor
	:inicio
	:final
	:inicioReversa
	:finalReversa
finclase
heredar Objeto Contenedor

[DOCUMENTA
@brief Obtiene un iterador apuntando al inicio de la secuencia.
Para determinar si este iterador esta al final, utilice <Contenedor\#final>
@argyo
@races None
DOCUMENTA]
funcion Contenedor#inicio
finfun

[DOCUMENTA
@brief Obtiene un iterador apuntando al final de la secuencia.
Para determinar si este iterador esta al inicio, utilice <Contenedor\#inicio>
@argyo
@races None
DOCUMENTA]
funcion Contenedor#final
finfun

[DOCUMENTA
@brief Obtiene un iterador en reversa apuntando al inicio de la secuencia.
Para determinar si este iterador esta al final, utilice
<Contenedor\#finalReversa>
@argyo
@races None
DOCUMENTA]
funcion Contenedor#inicioReversa
finfun

[DOCUMENTA
@brief Obtiene un iterador en reversa apuntando al final de la secuencia.
Para determinar si este iterador esta al inicio, utilice
<Contenedor\#inicioReversa>
@argyo
@races None
DOCUMENTA]
funcion Contenedor#finalReversa
finfun

[DOCUMENTA
@brief Es un arreglo dinámico de elementos.
A diferencia de un arreglo común, aqui los elementos no están en
posiciones sucesivas de memoria.

Puede obtener referencias a los elementos utiliando el método
<Arregle\#obtener>, o acceder a los elementos utilizando los atributos
dinámicos `#en<i>`
DOCUMENTA]
clase Arreglo
	tamaño
	:crear
	:destruir
	:obtener
	:agregar
finclase
heredar Contenedor Arreglo

[DOCUMENTA
@brief Crea el arreglo.
El arreglo inicial tiene un tamaño 0 y esta vacio.
@argyo
@races None
DOCUMENTA]
funcion Arreglo#crear [ ref yo ]
	adquirir yo
	recibir_parametro yo
	fijar <yo>#tamaño a {0}
	liberar yo
finfun

[DOCUMENTA
@brief Libera la memoria ocupada por el arreglo.
Adicionalmente, si se necesita destruir por completo el arreglo,
debes invocar a liberar.
@argyo
@races None
DOCUMENTA]
funcion Arreglo#destruir [ ref yo ]
	adquirir yo
	adquirir i
	recibir_parametro yo
	fijar i a {0}
	mientras comparar Importar.Ent.Comparar i < <yo>#tamaño
		liberar <yo>#en<i>
		fijar i a llamar Sumar i UNO finargs
	finbucle
	liberar yo
	liberar i
finfun

[DOCUMENTA
@brief Obtiene un elemento en una determinada posición.
Si la posición es invalida, devuelve <builtins.pseudo#NULO>.
@argyo
@arg i Índice del elemento, entre `0` y `tamaño`.
@dev Referencia al elemento.
@races None
DOCUMENTA]
funcion Arreglo#obtener [ ref yo, i -> ref at ]
	adquirir yo
	adquirir i
	recibir_parametro yo
	recibir_parametro i
	si comparar Importar.Ent.Comparar i >= <yo>#tamaño
		devolver NULO
	sino
		devolver <yo>#en<i>
	fin
	liberar i
	liberar yo
finfun

[DOCUMENTA
@brief Agrega un elemento al final.
También incrementa el tamaño del arreglo.
@argyo
@arg tipo Tipo del dato a agregar.
@dev Índice del nuevo elemento.
@races None
DOCUMENTA]
funcion Arreglo#agregar [ ref yo, tipo tipo -> indice ]
	adquirir yo
	adquirir tipo
	adquirir tm
	recibir_parametro yo
	recibir_parametro tipo
	fijar tm a <yo>#tamaño
	instancia <tipo> <yo>#en<tm>
	fijar <yo>#tamaño a llamar Sumar <yo>#tamaño {1} finargs
	liberar yo
	liberar tipo
	liberar tm
finfun
