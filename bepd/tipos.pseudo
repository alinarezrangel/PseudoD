[ ******************************************************************************
*****************************************
*********
** tipos.pseudo: Algoritmos de utilidad.
*********
*****************************************
********************************************************************************
Copyright 2016 Alejandro Linarez Rangel

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
********************************************************************************
****************************************************************************** ]

utilizar cadena.pseudo
utilizar entsal.pseudo

[DOCUMENTA
@file Documentación de tipos.pseudo.
Aqui se encuentran funciones comunes de PseudoD.

Este archivo contiene además la biblioteca de rasgos de tipo, la cual
detecta caracteristicas de objetos y tipos (clases) para su uso en
ducktyping y metaprogramación.
DOCUMENTA]

[DOCUMENTA
@brief Representa una referencia a un objeto.
Este requiere que se campo ref sea fijado a el nombre (ref) de la
variable a fijar. Esta variable puede ser una instancia de cualquier clase.

@obsolete
DOCUMENTA]
clase Referencia hereda Objeto
	atributo ref
	metodo obtenerAttrStr
	metodo obtenerAttr
	metodo fijarAttr
	metodo redireccionarAttr
	metodo llamarMet
	metodo obtenerValor
finclase

[DOCUMENTA
@brief Devuelve en forma de cadena, el atributo de la referencia.
Por ejemplo: si la referencia es A y el atributo es B devuelve A#B
@argyo
@arg attr Atributo a devolver.
@dev El atributo en forma de cadena.
@races None
DOCUMENTA]
funcion Referencia#obtenerAttrStr [ ref instancia, attr ]
	adquirir __REFERENCIA_OBT_ATTR_STR_REF__
	adquirir __REFERENCIA_OBT_ATTR_STR_BUFF__
	adquirir __REFERENCIA_OBT_ATTR_STR_BUFF2__
	adquirir __REFERENCIA_OBT_ATTR_STR_ATTR__
	recibir_parametro __REFERENCIA_OBT_ATTR_STR_REF__
	recibir_parametro __REFERENCIA_OBT_ATTR_STR_ATTR__
	fijar __REFERENCIA_OBT_ATTR_STR_BUFF2__ =* #
	Importar.Cad.Concatenar __REFERENCIA_OBT_ATTR_STR_BUFF2__ __REFERENCIA_OBT_ATTR_STR_ATTR__ __REFERENCIA_OBT_ATTR_STR_BUFF2__
	fijar __REFERENCIA_OBT_ATTR_STR_BUFF__ =* #ref
	Importar.Cad.Concatenar __REFERENCIA_OBT_ATTR_STR_REF__ __REFERENCIA_OBT_ATTR_STR_BUFF__ __REFERENCIA_OBT_ATTR_STR_REF__
	fijar __REFERENCIA_OBT_ATTR_STR_BUFF__ =* Importar.Cad.Concatenar
	Importar.Cad.Concatenar __REFERENCIA_OBT_ATTR_STR_BUFF__ __REFERENCIA_OBT_ATTR_STR_REF__ __REFERENCIA_OBT_ATTR_STR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_OBT_ATTR_STR_BUFF__ ESP __REFERENCIA_OBT_ATTR_STR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_OBT_ATTR_STR_BUFF__ __REFERENCIA_OBT_ATTR_STR_BUFF2__#NOMBRE __REFERENCIA_OBT_ATTR_STR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_OBT_ATTR_STR_BUFF__ ESP __REFERENCIA_OBT_ATTR_STR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_OBT_ATTR_STR_BUFF__ __REFERENCIA_OBT_ATTR_STR_BUFF__#NOMBRE __REFERENCIA_OBT_ATTR_STR_BUFF__
	ejecutar __REFERENCIA_OBT_ATTR_STR_BUFF__
	devolver __REFERENCIA_OBT_ATTR_STR_BUFF__
	liberar __REFERENCIA_OBT_ATTR_STR_ATTR__
	liberar __REFERENCIA_OBT_ATTR_STR_BUFF__
	liberar __REFERENCIA_OBT_ATTR_STR_BUFF2__
	liberar __REFERENCIA_OBT_ATTR_STR_REF__
finfun

[DOCUMENTA
@brief Devuelve el valor del atributo.
A diferencia de <Referencia\#obtenerAttrStr>, este devuelve el valor
del atributo, por ejemplo: dada la referencia A y el atributo B devuelve el valor
de `A#B` y no la cadena `A#B`.
@argyo
@arg attr Atributo a acceder.
@dev El valor del atributo.
@races Fatal.NonAttr
Si el atributo no existe, lanzara un error fatal.
DOCUMENTA]
funcion Referencia#obtenerAttr [ ref instancia, attr ]
	adquirir __REFERENCIA_OBT_ATTR_ATTR__
	adquirir __REFERENCIA_OBT_ATTR_BUFF__
	adquirir __REFERENCIA_OBT_ATTR_REF__
	adquirir __REFERENCIA_OBT_ATTR_BUFF2__
	recibir_parametro __REFERENCIA_OBT_ATTR_REF__
	recibir_parametro __REFERENCIA_OBT_ATTR_ATTR__
	fijar __REFERENCIA_OBT_ATTR_BUFF2__ =* #
	Importar.Cad.Concatenar __REFERENCIA_OBT_ATTR_BUFF2__ __REFERENCIA_OBT_ATTR_ATTR__ __REFERENCIA_OBT_ATTR_BUFF2__
	fijar __REFERENCIA_OBT_ATTR_BUFF__ =* #ref
	Importar.Cad.Concatenar __REFERENCIA_OBT_ATTR_REF__ __REFERENCIA_OBT_ATTR_BUFF__ __REFERENCIA_OBT_ATTR_REF__
	fijar __REFERENCIA_OBT_ATTR_BUFF__ =* Importar.Cad.Concatenar
	Importar.Cad.Concatenar __REFERENCIA_OBT_ATTR_BUFF__ __REFERENCIA_OBT_ATTR_REF__ __REFERENCIA_OBT_ATTR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_OBT_ATTR_BUFF__ ESP __REFERENCIA_OBT_ATTR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_OBT_ATTR_BUFF__ __REFERENCIA_OBT_ATTR_BUFF2__#NOMBRE __REFERENCIA_OBT_ATTR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_OBT_ATTR_BUFF__ ESP __REFERENCIA_OBT_ATTR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_OBT_ATTR_BUFF__ __REFERENCIA_OBT_ATTR_BUFF__#NOMBRE __REFERENCIA_OBT_ATTR_BUFF__
	ejecutar __REFERENCIA_OBT_ATTR_BUFF__
	fijar __REFERENCIA_OBT_ATTR_BUFF2__ =* devolver
	Importar.Cad.Concatenar __REFERENCIA_OBT_ATTR_BUFF2__ __REFERENCIA_OBT_ATTR_BUFF__ __REFERENCIA_OBT_ATTR_BUFF__
	ejecutar __REFERENCIA_OBT_ATTR_BUFF__
	liberar __REFERENCIA_OBT_ATTR_ATTR__
	liberar __REFERENCIA_OBT_ATTR_BUFF__
	liberar __REFERENCIA_OBT_ATTR_REF__
	liberar __REFERENCIA_OBT_ATTR_BUFF2__
finfun

[DOCUMENTA
@brief Devuelve el valor del atributo.
Devuelve su valor bruto.
@argyo
@dev El valor del atributo.
@races None
DOCUMENTA]
funcion Referencia#obtenerValor [ ref instancia ]
	adquirir __REFERENCIA_OBT_ATTR_ATTR__
	adquirir __REFERENCIA_OBT_ATTR_BUFF__
	adquirir __REFERENCIA_OBT_ATTR_REF__
	adquirir __REFERENCIA_OBT_ATTR_BUFF2__
	recibir_parametro __REFERENCIA_OBT_ATTR_REF__
	fijar __REFERENCIA_OBT_ATTR_BUFF__ =* #ref
	Importar.Cad.Concatenar __REFERENCIA_OBT_ATTR_REF__ __REFERENCIA_OBT_ATTR_BUFF__ __REFERENCIA_OBT_ATTR_REF__
	fijar __REFERENCIA_OBT_ATTR_BUFF__ =* empujar
	Importar.Cad.Concatenar __REFERENCIA_OBT_ATTR_BUFF__ __REFERENCIA_OBT_ATTR_REF__ __REFERENCIA_OBT_ATTR_BUFF__
	ejecutar __REFERENCIA_OBT_ATTR_BUFF__
	sacar __REFERENCIA_OBT_ATTR_BUFF2__
	fijar __REFERENCIA_OBT_ATTR_BUFF__ =* empujar
	Importar.Cad.Concatenar __REFERENCIA_OBT_ATTR_BUFF__ __REFERENCIA_OBT_ATTR_BUFF2__ __REFERENCIA_OBT_ATTR_BUFF__
	ejecutar __REFERENCIA_OBT_ATTR_BUFF__
	liberar __REFERENCIA_OBT_ATTR_ATTR__
	liberar __REFERENCIA_OBT_ATTR_BUFF__
	liberar __REFERENCIA_OBT_ATTR_REF__
	liberar __REFERENCIA_OBT_ATTR_BUFF2__
finfun

[DOCUMENTA
@brief Fija el valor del atributo.
En este proceso destruye el valor anterior.
@argyo
@arg attr Atributo a fijar.
@arg val Nuevo valor para el atributo.
@races Fatal.NonAttr
Si el atributo no existe, lanzara un error fatal.
DOCUMENTA]
funcion Referencia#fijarAttr [ ref instancia, attr, val ]
	adquirir __REFERENCIA_FJR_ATTR_ATTR__
	adquirir __REFERENCIA_FJR_ATTR_BUFF__
	adquirir __REFERENCIA_FJR_ATTR_REF__
	adquirir __REFERENCIA_FJR_ATTR_BUFF2__
	recibir_parametro __REFERENCIA_FJR_ATTR_REF__
	recibir_parametro __REFERENCIA_FJR_ATTR_ATTR__
	fijar __REFERENCIA_FJR_ATTR_BUFF2__ =* #
	Importar.Cad.Concatenar __REFERENCIA_FJR_ATTR_BUFF2__ __REFERENCIA_FJR_ATTR_ATTR__ __REFERENCIA_FJR_ATTR_BUFF2__
	fijar __REFERENCIA_FJR_ATTR_BUFF__ =* #ref
	Importar.Cad.Concatenar __REFERENCIA_FJR_ATTR_REF__ __REFERENCIA_FJR_ATTR_BUFF__ __REFERENCIA_FJR_ATTR_REF__
	fijar __REFERENCIA_FJR_ATTR_BUFF__ =* Importar.Cad.Concatenar
	Importar.Cad.Concatenar __REFERENCIA_FJR_ATTR_BUFF__ __REFERENCIA_FJR_ATTR_REF__ __REFERENCIA_FJR_ATTR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_FJR_ATTR_BUFF__ ESP __REFERENCIA_FJR_ATTR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_FJR_ATTR_BUFF__ __REFERENCIA_FJR_ATTR_BUFF2__#NOMBRE __REFERENCIA_FJR_ATTR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_FJR_ATTR_BUFF__ ESP __REFERENCIA_FJR_ATTR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_FJR_ATTR_BUFF__ __REFERENCIA_FJR_ATTR_BUFF__#NOMBRE __REFERENCIA_FJR_ATTR_BUFF__
	ejecutar __REFERENCIA_FJR_ATTR_BUFF__
	fijar __REFERENCIA_FJR_ATTR_BUFF2__ =* fijar
	Importar.Cad.Concatenar __REFERENCIA_FJR_ATTR_BUFF2__ __REFERENCIA_FJR_ATTR_BUFF__ __REFERENCIA_FJR_ATTR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_FJR_ATTR_BUFF__ ESP __REFERENCIA_FJR_ATTR_BUFF__
	fijar __REFERENCIA_FJR_ATTR_BUFF2__ =* =¿?
	Importar.Cad.Concatenar __REFERENCIA_FJR_ATTR_BUFF__ __REFERENCIA_FJR_ATTR_BUFF2__ __REFERENCIA_FJR_ATTR_BUFF__
	recibir_parametro __REFERENCIA_FJR_ATTR_BUFF2__
	Importar.Cad.Concatenar __REFERENCIA_FJR_ATTR_BUFF__ __REFERENCIA_FJR_ATTR_BUFF2__#NOMBRE __REFERENCIA_FJR_ATTR_BUFF__
	ejecutar __REFERENCIA_FJR_ATTR_BUFF__
	liberar __REFERENCIA_FJR_ATTR_ATTR__
	liberar __REFERENCIA_FJR_ATTR_BUFF__
	liberar __REFERENCIA_FJR_ATTR_REF__
	liberar __REFERENCIA_FJR_ATTR_BUFF2__
finfun

[DOCUMENTA
@brief Redirecciona el valor del atributo puntero.
Solo funciona si el atributo pasado es un puntero. Lo redirecciona a una
nueva variable.
@argyo
@arg attr Atributo puntero a redireccionar.
@arg var Variable a redireccionar el puntero(referencia comun).
@races Fatal.NonAttr
Si el atributo no existe, lanzara un error fatal.
DOCUMENTA]
funcion Referencia#redireccionarAttr [ ref instancia, attr, val ]
	adquirir __REFERENCIA_RED_ATTR_ATTR__
	adquirir __REFERENCIA_RED_ATTR_BUFF__
	adquirir __REFERENCIA_RED_ATTR_REF__
	adquirir __REFERENCIA_RED_ATTR_BUFF2__
	recibir_parametro __REFERENCIA_RED_ATTR_REF__
	recibir_parametro __REFERENCIA_RED_ATTR_ATTR__
	fijar __REFERENCIA_RED_ATTR_BUFF2__ =* #
	Importar.Cad.Concatenar __REFERENCIA_RED_ATTR_BUFF2__ __REFERENCIA_RED_ATTR_ATTR__ __REFERENCIA_RED_ATTR_BUFF2__
	fijar __REFERENCIA_RED_ATTR_BUFF__ =* #ref
	Importar.Cad.Concatenar __REFERENCIA_RED_ATTR_REF__ __REFERENCIA_RED_ATTR_BUFF__ __REFERENCIA_RED_ATTR_REF__
	fijar __REFERENCIA_RED_ATTR_BUFF__ =* Importar.Cad.Concatenar
	Importar.Cad.Concatenar __REFERENCIA_RED_ATTR_BUFF__ __REFERENCIA_RED_ATTR_REF__ __REFERENCIA_RED_ATTR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_RED_ATTR_BUFF__ ESP __REFERENCIA_RED_ATTR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_RED_ATTR_BUFF__ __REFERENCIA_RED_ATTR_BUFF2__#NOMBRE __REFERENCIA_RED_ATTR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_RED_ATTR_BUFF__ ESP __REFERENCIA_RED_ATTR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_RED_ATTR_BUFF__ __REFERENCIA_RED_ATTR_BUFF__#NOMBRE __REFERENCIA_RED_ATTR_BUFF__
	ejecutar __REFERENCIA_RED_ATTR_BUFF__
	fijar __REFERENCIA_RED_ATTR_BUFF2__ =* redireccionar
	Importar.Cad.Concatenar __REFERENCIA_RED_ATTR_BUFF2__ __REFERENCIA_RED_ATTR_BUFF__ __REFERENCIA_RED_ATTR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_RED_ATTR_BUFF__ ESP __REFERENCIA_RED_ATTR_BUFF__
	recibir_parametro __REFERENCIA_RED_ATTR_BUFF2__
	Importar.Cad.Concatenar __REFERENCIA_RED_ATTR_BUFF__ __REFERENCIA_RED_ATTR_BUFF2__ __REFERENCIA_RED_ATTR_BUFF__
	ejecutar __REFERENCIA_RED_ATTR_BUFF__
	liberar __REFERENCIA_RED_ATTR_ATTR__
	liberar __REFERENCIA_RED_ATTR_BUFF__
	liberar __REFERENCIA_RED_ATTR_REF__
	liberar __REFERENCIA_RED_ATTR_BUFF2__
finfun

[DOCUMENTA
@brief Llama al metodo de la referencia.
@argyo
@arg met Metodo a llamar
@arg args Argumentos a pasar.
@dev El resultado de la funcion.
@races Fatal.NonAttr
Si el método no existe, lanzara un error fatal.
DOCUMENTA]
funcion Referencia#llamarMet [ ref instancia, met, args... ]
	adquirir __REFERENCIA_LMR_ATTR_ATTR__
	adquirir __REFERENCIA_LMR_ATTR_BUFF__
	adquirir __REFERENCIA_LMR_ATTR_REF__
	adquirir __REFERENCIA_LMR_ATTR_BUFF2__
	recibir_parametro __REFERENCIA_LMR_ATTR_REF__
	recibir_parametro __REFERENCIA_LMR_ATTR_ATTR__
	fijar __REFERENCIA_LMR_ATTR_BUFF2__ =* #
	Importar.Cad.Concatenar __REFERENCIA_LMR_ATTR_BUFF2__ __REFERENCIA_LMR_ATTR_ATTR__ __REFERENCIA_LMR_ATTR_BUFF2__
	fijar __REFERENCIA_LMR_ATTR_BUFF__ =* #ref
	Importar.Cad.Concatenar __REFERENCIA_LMR_ATTR_REF__ __REFERENCIA_LMR_ATTR_BUFF__ __REFERENCIA_LMR_ATTR_REF__
	fijar __REFERENCIA_LMR_ATTR_BUFF__ =* Importar.Cad.Concatenar
	Importar.Cad.Concatenar __REFERENCIA_LMR_ATTR_BUFF__ __REFERENCIA_LMR_ATTR_REF__ __REFERENCIA_LMR_ATTR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_LMR_ATTR_BUFF__ ESP __REFERENCIA_LMR_ATTR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_LMR_ATTR_BUFF__ __REFERENCIA_LMR_ATTR_BUFF2__#NOMBRE __REFERENCIA_LMR_ATTR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_LMR_ATTR_BUFF__ ESP __REFERENCIA_LMR_ATTR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_LMR_ATTR_BUFF__ __REFERENCIA_LMR_ATTR_BUFF__#NOMBRE __REFERENCIA_LMR_ATTR_BUFF__
	ejecutar __REFERENCIA_LMR_ATTR_BUFF__
	fijar __REFERENCIA_LMR_ATTR_BUFF2__ =* llamar
	Importar.Cad.Concatenar __REFERENCIA_LMR_ATTR_BUFF2__ __REFERENCIA_LMR_ATTR_BUFF__ __REFERENCIA_LMR_ATTR_BUFF__
	fijar __REFERENCIA_LMR_ATTR_BUFF2__ =* #(Final).
	Importar.Cad.Concatenar __REFERENCIA_LMR_ATTR_BUFF__ ESP __REFERENCIA_LMR_ATTR_BUFF__
	Importar.Cad.Concatenar __REFERENCIA_LMR_ATTR_BUFF__ __REFERENCIA_LMR_ATTR_BUFF2__ __REFERENCIA_LMR_ATTR_BUFF__
	ejecutar __REFERENCIA_LMR_ATTR_BUFF__
	liberar __REFERENCIA_LMR_ATTR_ATTR__
	liberar __REFERENCIA_LMR_ATTR_BUFF__
	liberar __REFERENCIA_LMR_ATTR_REF__
	liberar __REFERENCIA_LMR_ATTR_BUFF2__
finfun

[DOCUMENTA
@brief Crea un atributo dinamico.
Equivalente a escribir `instancia tattr yo#nattr`.

@arg yo Nombre de la instancia sobre la que se creara el atributo.
@arg nattr Nombre del atributo a crear.
@arg tattr Tipo de latributo a crear.

@races Fatal.HaveAttr
Si el atributo ya existe, lanzara un error fatal.
DOCUMENTA]
funcion CrearAtributoDinamico de yo y nombre_atributo y tipo_atributo
	[ instancia tattr yo#nattr ]
	instancia <tipo_atributo> <yo>#<nombre_atributo>
finfun

[DOCUMENTA
@brief Destruye un atributo dinamico.
Este puede ser creado con <CrearAtributoDinamico>.

@arg yo Instancia sobre la que existe el atributo.
@arg nattr Nombre del atributo.

@races Fatal.NonAttr
De ya estar destruido el atributo, lanzara un error fatal.
DOCUMENTA]
funcion DestruirAtributoDinamico de yo y nombre_atributo
	[ instancia tattr yo#nattr ]
	liberar <yo>#<nombre_atributo>
finfun

[DOCUMENTA
@brief Determina si el tipo posee en su **declaración** el método.
Aunque posea en su declaración el método dado, no hay garantías de que
se pueda llamar de forma segura dicho método en un objeto.

@arg tipo Tipo (no referencia a tipo) o clase en el cual se buscará el método
@arg nombre_metodo Nombre del método a buscar.

@dev VERDADERO si el tipo posee el método o FALSO de lo contrario.

@races Fatal.NotAType
Si el tipo no es una clase su comportamiento está indefinido.

Por ejemplo: nunca se debe llamar a esta función como:

```
llamar PoseeMetodo PseudoVariable#Tipo {...} finargs
```

Sino directamente como:

```
llamar PoseeMetodo PseudoVariable {...} finargs
```
DOCUMENTA]
funcion PoseeMetodo de tipo y nombre_metodo
	fijar nombre_metodo a
		llamar Cadena#Concatenar
			{:}
			llamar Cadena#Concatenar
				nombre_metodo
				{ }
			finargs
		finargs

	si son iguales llamar Cadena#Buscar tipo nombre_metodo finargs y CMMERROR
		devolver FALSO
	sino
		devolver VERDADERO
	fin
finfun

[DOCUMENTA
@brief Determina si el tipo posee en su **declaración** el atributo.
No puede detectar atributos creados dinámicamente.

@arg tipo Tipo (no referencia a tipo) o clase en el cual se buscará el atributo
@arg nombre_atributo Nombre del atributo a buscar.

@dev VERDADERO si el tipo posee el atributo o FALSO de lo contrario.

@races Fatal.NotAType
Si el tipo no es una clase su comportamiento está indefinido.

Por ejemplo: nunca se debe llamar a esta función como:

```
llamar PoseeAtributo PseudoVariable#Tipo {...} finargs
```

Sino directamente como:

```
llamar PoseeAtributo PseudoVariable {...} finargs
```
DOCUMENTA]
funcion PoseeAtributo de tipo y nombre_atributo
	fijar nombre_metodo a
		llamar Cadena#Concatenar
			nombre_atributo
			{ }
		finargs

	si son iguales llamar Cadena#Buscar tipo nombre_atributo finargs y CMMERROR
		devolver FALSO
	sino
		devolver VERDADERO
	fin
finfun

[DOCUMENTA
@brief Determina si el tipo posee en su **declaración** el puntero.
No puede detectar punteros creados dinámicamente.

@arg tipo Tipo (no referencia a tipo) o clase en el cual se buscará el puntero
@arg nombre_puntero Nombre del puntero a buscar.

@dev VERDADERO si el tipo posee el puntero o FALSO de lo contrario.

@races Fatal.NotAType
Si el tipo no es una clase su comportamiento está indefinido.

Por ejemplo: nunca se debe llamar a esta función como:

```
llamar PoseePuntero PseudoVariable#Tipo {...} finargs
```

Sino directamente como:

```
llamar PoseePuntero PseudoVariable {...} finargs
```
DOCUMENTA]
funcion PoseePuntero de tipo y nombre_puntero
	fijar nombre_metodo a
		llamar Cadena#Concatenar
			{;}
			llamar Cadena#Concatenar
				nombre_puntero
				{ }
			finargs
		finargs

	si son iguales llamar Cadena#Buscar tipo nombre_puntero finargs y CMMERROR
		devolver FALSO
	sino
		devolver VERDADERO
	fin
finfun

[DOCUMENTA
@brief Bandera global que indica si <Asertar> deberia terminar el programa.
De ser VERDADERO, cuando se llame a `Asertar ... FALSO` o equivalente
se terminará con el programa ejecutando `necesitas FALSO`. En caso contrario,
solo se imrpimirá una advertencia de acuerdo a
<VG_ASERTAR_NO_IMPRIME_ADVERTENCIAS>.
DOCUMENTA]
adquirir VG_ASERTAR_FALSO_ES_FATAL

[DOCUMENTA
@brief Bandera global que indica si <Asertar> debe imprimir una advertencia.
Cuando <VG_ASERTAR_FALSO_ES_FATAL> es FALSO y se llega a una llamada equivalente
a `Asertar ... FALSO`, de ser esta bandera FALSO entonces se imprimirá una
advertencia indicando que se continuará con el flujo del programa. De ser
VERDADERO, <Asertar> no hará náda más que imprimir el mensaje especificado
cuando la condición sea falsa.
DOCUMENTA]
adquirir VG_ASERTAR_NO_IMPRIME_ADVERTENCIAS

fijar VG_ASERTAR_FALSO_ES_FATAL a VERDADERO
fijar VG_ASERTAR_NO_IMPRIME_ADVERTENCIAS a FALSO

[DOCUMENTA
@brief Termina con el programa si la condición es falsa.
Similar al `static_assert` de C++, esta función termina con el programa
cuando la condición es falsa (`condicion` es igual a FALSO). Al terminar
con el programa, muestra al usuario el mensaje de error que se pasó como
argumento. Véase <VG_ASERTAR_FALSO_ES_FATAL> y
<VG_ASERTAR_NO_IMPRIME_ADVERTENCIAS>.

@arg mensaje Mensaje a imprimir si la condición se evalua falsa
@arg condicion Variable Booleana que indica el estado de la condición

@throws ErrorDeSemantica
Ejecuta `necesitas FALSO` cuando la condición es falsa, `necesitas` lanza
un error de semantica y por ende, esta función también.
DOCUMENTA]
funcion Asertar de mensaje y condicion
	si no condicion
		llamar ImprimirLinea
			{Error fatal en Asertar (tipos.pseudo):}
			mensaje
			NULO
		finargs
		si VG_ASERTAR_FALSO_ES_FATAL
			necesitas FALSO
		sino
			si no VG_ASERTAR_NO_IMPRIME_ADVERTENCIAS
				llamar EscribirLinea
					{Advertencia en Asertar (tipos.pseudo): VG_ASERTAR_FALSO_ES_FATAL es FALSO}
				finargs
			fin
		fin
	fin
finfun
