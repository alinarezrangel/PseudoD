[ ******************************************************************************
*****************************************
*********
** mate.pseudo: Funciones matematicas de PseudoD
** Declara funciones matemáticas.
** PseudoD fue creado por Alejandro Linarez Rangel
** mate.pseudo fue creado por Alejandro Linarez Rangel
** Puede copiar, redistribuir y modificar este archivo con permiso de
** <proyectopseudod@gmail.com>.
*****************************************
****************************************************************************** ]

utilizar cadena.pseudo

[DOCUMENTA
@file Documentación de mate.pseudo.
Esta es la biblioteca matemática de PseudoD, aqui estan todas las
funciones matemáticas de PseudoD implementadas en PseudoD.
DOCUMENTA]

[DOCUMENTA
@brief Valor PI.
Es el valor 3.14159...
DOCUMENTA]
adquirir PI
fijar PI a {3.141595}

[DOCUMENTA
@brief Constante de Napier.
Es el valor 2.718281...
DOCUMENTA]
adquirir E
fijar E a {2.718281}

[DOCUMENTA
@brief Valor para comparar decimales.
Es aproximadamente 0.000005.
DOCUMENTA]
adquirir DELTA
fijar DELTA a {0.000005}

[DOCUMENTA
@brief Mayor cantidad de decimales que puede almacenar un numero.
Es el limite visualizable de <code class="cpp">long double</code>,(para numeros
mayores, se visualizaran con notacion cientifica).
DOCUMENTA]
adquirir PRECISION_DECIMAL
fijar PRECISION_DECIMAL a {6}

[DOCUMENTA
@brief Es el punto de inicio de la funcion RaizCuadrada.
A menor valor, mayor es la precicion de la funcion pero es mas lenta.
DOCUMENTA]
adquirir RAIZ_CUADRADA_MIN
fijar RAIZ_CUADRADA_MIN a {0.0001}

[DOCUMENTA
@brief Es un valor que no es un numero.
Representa valores indeterminados, como una division entre cero.
DOCUMENTA]
adquirir NO_ES_NUMERO
fijar NO_ES_NUMERO a {**(No es un numero)**}

[DOCUMENTA
@brief Es la cantidad de veces que la función seno itera.
Es inversamente proporcional a la velocidad.
@pbreak
Como Seno(x) utiliza series de Taylor para calcular el seno, este determina
cuantas veces se tendra que iterar, un numero mayor o igual a cinco(5) ya
se vuelve lento. Si se requiere una alta precisión, puede seleccionar
un numero alto, como 7 o 9, pero esto es a costa de la velocidad. Si por
el contrario, se requiere una precisión promedio, puede dejarlo en su
valor predeterminado o en 5. Recuerde que este numero tambien es utilizado
por Coseno(x) y Tangente(x), y la función Tangente(x) dura el doble
que las otras dos, por lo que un numero muy elevado para calcular tangentes
es altamente ineficiente.
DOCUMENTA]
adquirir ITERACIONES_DE_SENO
fijar ITERACIONES_DE_SENO a {5}

[DOCUMENTA
@brief Determina si dos decimales son aproximadamente iguales.
Nunca de debe comparar decimales con "son iguales" o
"comparar Importar.Dec.Comparar", esto puede ocasionar fallas
poco esperadas.
@pbreak
Utiliza DELTA
@arg dec1 Decimal número 1 a comparar
@arg dec2 Decimal número 2 a comparar
@dev Si son aproximadamente iguales.
DOCUMENTA]
funcion SonIguales [ dec1, dec2 ]
	adquirir dec1
	adquirir dec2
	adquirir resta
	recibir_parametro dec1
	recibir_parametro dec2
	Importar.Dec.Restar dec1 dec2 resta
	si comparar Importar.Dec.Comparar resta < CERO
		Importar.Dec.Restar CERO resta resta
	fin
	si comparar Importar.Dec.Comparar resta < DELTA
		devolver VERDADERO
	sino
		devolver FALSO
	fin
	liberar dec1
	liberar dec2
	liberar resta
finfun

[DOCUMENTA
@brief Suma dos numeros.
Si los numeros son enteros, aplica la suma entera, en otro caso aplica
la suma decimal.
@pbreak
Determina si son enteros o no buscando un separador decimal ("," o ".") en
los numeros.
@arg lvalue Valor izquierdo a sumar.
@arg rvalue Valor derecho a sumar.
@dev Decimal resultado de la suma.
DOCUMENTA]
funcion Sumar [ lvalue, rvalue -> res ]
	adquirir lv
	adquirir rv
	adquirir sr
	adquirir decimal
	recibir_parametro lv
	recibir_parametro rv
	fijar decimal a FALSO
	si son diferentes llamar Cadena#Buscar lv {.} finargs y CMMERROR
		fijar decimal a VERDADERO
	sino
		si son diferentes llamar Cadena#Buscar rv {.} finargs y CMMERROR
			fijar decimal a VERDADERO
		fin
	fin
	si decimal
		Importar.Dec.Sumar lv rv sr
	sino
		Importar.Ent.Sumar lv rv sr
	fin
	devolver sr
	liberar lv
	liberar rv
	liberar sr
	liberar decimal
finfun

[DOCUMENTA
@brief Resta dos numeros.
Si los numeros son enteros, aplica la resta entera, en otro caso aplica
la resta decimal.
@pbreak
Determina si son enteros o no buscando un separador decimal ("," o ".") en
los numeros.
@arg lvalue Valor izquierdo a restar.
@arg rvalue Valor derecho a restar.
@dev Decimal resultado de la resta.
DOCUMENTA]
funcion Restar [ lvalue, rvalue -> res ]
	adquirir lv
	adquirir rv
	adquirir sr
	adquirir decimal
	recibir_parametro lv
	recibir_parametro rv
	fijar decimal a FALSO
	si son diferentes llamar Cadena#Buscar lv {.} finargs y CMMERROR
		fijar decimal a VERDADERO
	sino
		si son diferentes llamar Cadena#Buscar rv {.} finargs y CMMERROR
			fijar decimal a VERDADERO
		fin
	fin
	si decimal
		Importar.Dec.Restar lv rv sr
	sino
		Importar.Ent.Restar lv rv sr
	fin
	devolver sr
	liberar lv
	liberar rv
	liberar sr
	liberar decimal
finfun

[DOCUMENTA
@brief Multiplica dos numeros.
Si los numeros son enteros, aplica la multiplicación entera, en otro caso aplica
la multiplicación decimal.
@pbreak
Determina si son enteros o no buscando un separador decimal ("," o ".") en
los numeros.
@arg lvalue Valor izquierdo a multiplicar.
@arg rvalue Valor derecho a multiplicar.
@dev Decimal resultado de la multiplicación.
DOCUMENTA]
funcion Multiplicar [ lvalue, rvalue -> res ]
	adquirir lv
	adquirir rv
	adquirir sr
	adquirir decimal
	recibir_parametro lv
	recibir_parametro rv
	fijar decimal a FALSO
	si son diferentes llamar Cadena#Buscar lv {.} finargs y CMMERROR
		fijar decimal a VERDADERO
	sino
		si son diferentes llamar Cadena#Buscar rv {.} finargs y CMMERROR
			fijar decimal a VERDADERO
		fin
	fin
	si decimal
		Importar.Dec.Multiplicar lv rv sr
	sino
		Importar.Ent.Multiplicar lv rv sr
	fin
	devolver sr
	liberar lv
	liberar rv
	liberar sr
	liberar decimal
finfun

[DOCUMENTA
@brief Divide dos numeros.
Si los numeros son enteros, aplica la división entera, en otro caso aplica
la división decimal.
@pbreak
Determina si son enteros o no buscando un separador decimal ("," o ".") en
los numeros.
@arg lvalue Valor izquierdo a dividir.
@arg rvalue Valor derecho a dividir.
@dev Decimal resultado de la división.
DOCUMENTA]
funcion Dividir [ lvalue, rvalue -> res ]
	adquirir lv
	adquirir rv
	adquirir sr
	adquirir decimal
	recibir_parametro lv
	recibir_parametro rv
	fijar decimal a FALSO
	si son diferentes llamar Cadena#Buscar lv {.} finargs y CMMERROR
		fijar decimal a VERDADERO
	sino
		si son diferentes llamar Cadena#Buscar rv {.} finargs y CMMERROR
			fijar decimal a VERDADERO
		fin
	fin
	si decimal
		Importar.Dec.Dividir lv rv sr
	sino
		Importar.Ent.Dividir lv rv sr
	fin
	devolver sr
	liberar lv
	liberar rv
	liberar sr
	liberar decimal
finfun

[DOCUMENTA
@brief Calcula el valor de una base elevado a un exponente.
@arg base Base de la potencia
@arg exponente Exponente de la potencia
@dev El resultado de base^exponente.
@errors Active
DOCUMENTA]
funcion ElevarValor [ base,expo ]
	adquirir base
	adquirir exponente
	adquirir resultado
	adquirir acumulador
	adquirir cuenta
	recibir_parametro base
	recibir_parametro exponente
	fijar cuenta a UNO
	fijar acumulador a base
	mientras comparar Importar.Ent.Comparar cuenta < exponente
		Importar.Dec.Multiplicar acumulador base acumulador
		Importar.Ent.Sumar cuenta UNO cuenta
	finbucle
	devolver acumulador
	liberar cuenta
	liberar acumulador
	liberar resultado
	liberar exponente
	liberar base
finfun

[DOCUMENTA
@brief Calcula el factorial de un numero n.
Si n < 0,  devuelve 1 al igual que si n == 0 o 1.
@arg n Numero a calcular el factorial.
@dev El factorial de dicho numero, o 1.
@errors Active
DOCUMENTA]
funcion Factorial
	adquirir numero
	adquirir factorial
	recibir_parametro numero
	fijar factorial a numero
	si comparar Importar.Dec.Comparar numero <= CERO
		fijar factorial a UNO
	fin
	mientras comparar Importar.Dec.Comparar numero > CERO
		Importar.Dec.Restar numero UNO numero
		Importar.Dec.Multiplicar factorial numero factorial
	finbucle
	devolver factorial
	liberar numero
	liberar factorial
finfun

[DOCUMENTA
@brief Convierte grados sexadecimales a radianes.
@arg grados Grados a convertir
@dev El valor en Radianes
@errors Active
DOCUMENTA]
funcion GradosARadianes
	adquirir grados
	adquirir radianes
	adquirir divisor
	recibir_parametro grados
	Importar.Dec.Multiplicar grados PI grados
	fijar divisor a {180}
	Importar.Dec.Dividir grados divisor radianes
	devolver radianes
	liberar grados
	liberar radianes
	liberar divisor
finfun

[DOCUMENTA
@brief Convierte radianes a grados sexadecimales.
@arg radianes Valor en radianes a convertir
@dev El valor en Grados sexadecimales
@errors Active
DOCUMENTA]
funcion RadianesAGrados
	adquirir grados
	adquirir radianes
	adquirir divisor
	recibir_parametro radianes
	fijar divisor a {180}
	Importar.Dec.Multiplicar radianes divisor radianes
	Importar.Dec.Dividir radianes PI grados
	devolver grados
	liberar radianes
	liberar grados
	liberar divisor
finfun

[DOCUMENTA
@brief Calcula el valor absoluto de un numero.
El valor absoluto de un numero x, es |x| y se define
como {x Si x >= 0} o {-x Si < 0}, es decir, siempre es
positivo.
@arg val Valor a calcular el valor absoluto.
@dev El valor absoluto de val.
@errors Active
DOCUMENTA]
funcion ValorAbsoluto [ val ]
	adquirir valor
	recibir_parametro valor
	si comparar Importar.Dec.Comparar valor < CERO
		Importar.Dec.Restar CERO valor valor
	fin
	devolver valor
	liberar valor
finfun

[DOCUMENTA
@brief Ajusta un numero decimal para el seno/coseno.
Simplemente lo reduce al rango [0-PI).
@arg ang Angulo a ajustar.
@dev Angulo ajustado.
@errors Active
DOCUMENTA]
funcion AjustarParaSeno [ ang ]
	adquirir ang
	adquirir per
	recibir_parametro ang
	fijar per a PI
	Importar.Dec.Multiplicar per DOS per
	si comparar Importar.Dec.Comparar ang < CERO
		llamar Valor_absoluto ang finargs
		recibir_resultado ang
	fin
	mientras comparar Importar.Dec.Comparar ang >= per
		Importar.Dec.Restar ang per ang
	finbucle
	devolver ang
	liberar ang
	liberar per
finfun

[DOCUMENTA
@brief Calcula el seno de un angulo.
@arg ang Angulo en radianes.
@dev Decimal resultado del seno.
@errors Active
DOCUMENTA]
funcion Seno [ ang ]
	[ **********************************************
		Breve explicación del algoritmo:
		Podemos definir el seno de x como:
			sin(x) = SUM(0 -> inf,n){((-1)^n)((x^(2n+1))/((2n+1)!))}
		Por lo tanto, si x esta en el rango 0 <= x <= PI
		entonces las iteraciones son minimas.
		La funcion Seno primero llama a Ajustar_para_seno,
		el cual ajusta un numero hasta el rango 0 <= x <= PI.
		.
		La implementación no es muy compleja debido a
		que ya existen las funciones Elevar_valor y
		Factorial.
		.
		Solo necesitamos la parte positiva dado que
			sin(-x) = -sin(x)
			sin(x) = -sin(-x)
		Coseno utiliza esta función por la igualdad:
			cos(x) = sin((PI/2) - x)
	********************************************** ]
	adquirir __Seno_ang__
	adquirir __Seno_rang__
	adquirir __Seno_cuenta__
	adquirir __Seno_hasta__
	adquirir __Seno_resultado__
	adquirir __Seno_va__
	adquirir __Seno_vb__
	adquirir __Seno_vc__
	adquirir __Seno_op__
	recibir_parametro __Seno_ang__
	fijar __Seno_rang__ =¿? __Seno_ang__
	llamar AjustarParaSeno __Seno_ang__ #(Final).
	recibir_resultado __Seno_ang__
	fijar __Seno_cuenta__ =* 0
	fijar __Seno_hasta__ =¿? ITERACIONES_DE_SENO
	fijar __Seno_resultado__ =* 0.0
	fijar __Seno_va__ =* 0
	fijar __Seno_vb__ =* 1
	fijar __Seno_vc__ =* 0
	fijar __Seno_op__ =¿? VERDADERO
	mientras comparar Importar.Ent.Comparar __Seno_cuenta__ < __Seno_hasta__
		Importar.Dec.Multiplicar DOS __Seno_cuenta__ __Seno_va__
		Importar.Dec.Sumar UNO __Seno_va__ __Seno_va__
		fijar __Seno_vb__ =¿? __Seno_va__
		llamar ElevarValor __Seno_ang__ __Seno_va__ #(Final).
		recibir_resultado __Seno_va__
		llamar Factorial __Seno_vb__ #(Final).
		recibir_resultado __Seno_vb__
		Importar.Dec.Dividir __Seno_va__ __Seno_vb__ __Seno_va__
		si __Seno_op__
			Importar.Dec.Sumar __Seno_resultado__ __Seno_va__ __Seno_resultado__
			fijar __Seno_op__ =¿? FALSO
		sino
			Importar.Dec.Restar __Seno_resultado__ __Seno_va__ __Seno_resultado__
			fijar __Seno_op__ =¿? VERDADERO
		fin
		Importar.Ent.Sumar __Seno_cuenta__ UNO __Seno_cuenta__
	finbucle
	si comparar Importar.Dec.Comparar __Seno_rang__ < CERO
		Importar.Dec.Restar CERO __Seno_resultado__ __Seno_resultado__
	fin
	devolver __Seno_resultado__
	liberar __Seno_cuenta__
	liberar __Seno_hasta__
	liberar __Seno_ang__
	liberar __Seno_rang__
	liberar __Seno_resultado__
	liberar __Seno_va__
	liberar __Seno_vb__
	liberar __Seno_vc__
	liberar __Seno_op__
finfun

[DOCUMENTA
@brief Calcula el coseno de un angulo.
Realmente llama a Seno((PI/2) - ang), lo cual es equivalente.
@arg ang Angulo en radianes.
@dev El coseno del angulo.
@errors Active
DOCUMENTA]
funcion Coseno [ ang ]
	adquirir angulo
	adquirir defase
	recibir_parametro angulo
	fijar defase =¿? PI
	Importar.Dec.Dividir defase DOS defase
	Importar.Dec.Restar defase angulo angulo
	llamar Seno angulo #(Final).
	liberar defase
	liberar angulo
finfun

[DOCUMENTA
@brief Calcula la raiz cuadrada de un numero.
utiliza el metodo babilonico para calcular la raiz cuadrada de un numero.
@arg nm Numero a radicar.
@dev Decimal resultado de la radicacion.
@errors Active
DOCUMENTA]
funcion RaizCuadrada [ nm -> sqrt(nm) ]
	adquirir area
	adquirir base
	adquirir altura
	recibir_parametro area
	fijar base a {0.5}
	fijar altura a RAIZ_CUADRADA_MIN
	mientras no llamar SonIguales base altura finargs
		fijar base a llamar Dividir
			llamar Sumar
				base
				altura
			finargs
			{2}
		finargs
		fijar altura a llamar Dividir
			area
			base
		finargs
	finbucle
	devolver base
	liberar altura
	liberar base
	liberar area
finfun

[ FIXME: Poco legible
funcion RaizCuadrada
	adquirir __raizcuadrada_a__
	adquirir __raizcuadrada_an__
	adquirir __raizcuadrada_anu__
	adquirir __raizcuadrada_cpc__
	adquirir __raizcuadrada_buf__
	recibir_parametro __raizcuadrada_a__
	fijar __raizcuadrada_cpc__ =* 0.5
	fijar __raizcuadrada_anu__ =¿? RAIZ_CUADRADA_MIN
	fijar __raizcuadrada_an__ =* 0
	mientras sean diferentes __raizcuadrada_an__ y __raizcuadrada_anu__
		fijar __raizcuadrada_an__ =¿? __raizcuadrada_anu__
		Importar.Dec.Dividir __raizcuadrada_a__ __raizcuadrada_an__ __raizcuadrada_buf__
		Importar.Dec.Sumar __raizcuadrada_buf__ __raizcuadrada_an__ __raizcuadrada_buf__
		Importar.Dec.Multiplicar __raizcuadrada_buf__ __raizcuadrada_cpc__ __raizcuadrada_anu__
	finbucle
	devolver __raizcuadrada_an__
	liberar __raizcuadrada_a__
	liberar __raizcuadrada_an__
	liberar __raizcuadrada_anu__
	liberar __raizcuadrada_cpc__
	liberar __raizcuadrada_buf__
finfun
[ $END$ ]

[DOCUMENTA
@brief Calcula el piso de un numero.
El piso de X, es el numero entero menor o igual más cercano a X.
Por ejemplo: piso(3.232) = 3, piso(3.99999) = 3, piso(8) = 8.
@arg nm Numero a calcular el piso.
@dev El piso de nm.
@errors Active
DOCUMENTA]
funcion Piso [ nm -> floor(nm) ]
	adquirir valor
	recibir_parametro valor
	Importar.Ent.Sumar valor CERO valor [ La suma de enteros redondea a cero ]
	devolver valor
	liberar valor
finfun

[DOCUMENTA
@brief Calcula el techo de un numero.
El techo de X, es el numero entero mayor o igual más cercano a X.
Por ejemplo: techo(3.232) = 4, techo(3.99999) = 4, techo(8) = 8.
@arg nm Numero a calcular el techo.
@dev El techo de nm.
@errors Active
DOCUMENTA]
funcion Techo [ nm -> ceil(nm) ]
	adquirir valor
	adquirir techo
	recibir_parametro valor
	Importar.Ent.Sumar valor CERO __techo_bff__
	si comparar Importar.Dec.Comparar valor = techo [ "son iguales" podria fallar por precisión ]
		devolver techo
	sino
		Importar.Ent.Sumar valor UNO valor
		devolver valor
	fin
	liberar valor
	liberar techo
finfun

[DOCUMENTA
@brief Es una division
Posee todos los datos de una division.
Con este se puede calcular el resto y cociente de una division.
DOCUMENTA]
clase Division
	resto
	cociente
	:divide
#(Final).
heredar Objeto Division

[DOCUMENTA
@brief Divide dos numeros.
Los datos de la division son almacenados en la instancia actual.
De ser el divisor cero, no realizara accion.
@argyo
@arg dividendo Numero a dividir.
@arg divisor Numero que dividira.
@errors Active
DOCUMENTA]
funcion Division#divide [ yo, a, b :: yo.cociente = a/b yo.resto = a % b ]
	instancia Referencia __Division_divide_yo__
	adquirir __Division_divide_a__
	adquirir __Division_divide_b__
	adquirir __Division_divide_coc__
	adquirir __Division_divide_res__
	adquirir __Division_divide_mt__
	recibir_parametro __Division_divide_yo__#ref
	recibir_parametro __Division_divide_a__
	recibir_parametro __Division_divide_b__
	si comparar Importar.Ent.Comparar __Division_divide_b__ != CERO
		Importar.Ent.Dividir __Division_divide_a__ __Division_divide_b__ __Division_divide_coc__
		fijar __Division_divide_mt__ =* cociente
		llamar __Division_divide_yo__#fijarAttr __Division_divide_mt__ __Division_divide_coc__ #(Final).
		Importar.Ent.Restar CERO __Division_divide_b__ __Division_divide_res__
		Importar.Ent.Multiplicar __Division_divide_res__ __Division_divide_coc__ __Division_divide_res__
		Importar.Ent.Sumar __Division_divide_res__ __Division_divide_a__ __Division_divide_res__
		fijar __Division_divide_mt__ =* resto
		llamar __Division_divide_yo__#fijarAttr __Division_divide_mt__ __Division_divide_res__ #(Final).
	fin
	liberar __Division_divide_yo__
	liberar __Division_divide_a__
	liberar __Division_divide_b__
	liberar __Division_divide_coc__
	liberar __Division_divide_res__
	liberar __Division_divide_mt__
finfun

