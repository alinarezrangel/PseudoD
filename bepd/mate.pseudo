[ ******************************************************************************
*****************************************
*********
** mate.pseudo: Funciones matematicas de PseudoD
*********
*****************************************
********************************************************************************
Copyright 2016 Alejandro Linarez Rangel

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
********************************************************************************
****************************************************************************** ]

utilizar cadena.pseudo

[DOCUMENTA
@file Documentación de mate.pseudo.
Esta es la biblioteca matemática de PseudoD, aqui estan todas las funciones
matemáticas de PseudoD implementadas en PseudoD.
DOCUMENTA]

[DOCUMENTA
@brief Valor PI.
Es el valor 3.14159...
DOCUMENTA]
adquirir PI
fijar PI a {3.141595}

[DOCUMENTA
@brief Constante de Napier.
Es el valor 2.718281...
DOCUMENTA]
adquirir E
fijar E a {2.718281}

[DOCUMENTA
@brief Valor para comparar decimales.
Es aproximadamente 0.000005.
DOCUMENTA]
adquirir DELTA
fijar DELTA a {0.000005}

[DOCUMENTA
@brief Mayor cantidad de decimales que puede almacenar un numero.
Es el limite visualizable de `long double` (para numeros mayores, se
visualizarán con notación científica).
DOCUMENTA]
adquirir PRECISION_DECIMAL
fijar PRECISION_DECIMAL a {6}

[DOCUMENTA
@brief Es el punto de inicio de la funcion <RaizCuadrada>.
A menor valor, mayor es la precicion de la funcion pero es mas lenta.
DOCUMENTA]
adquirir RAIZ_CUADRADA_MIN
fijar RAIZ_CUADRADA_MIN a {0.0001}

[DOCUMENTA
@brief Es un valor que no es un numero.
Representa valores indeterminados, como una division entre cero.
DOCUMENTA]
adquirir NO_ES_NUMERO
fijar NO_ES_NUMERO a {**(No es un numero)**}

[DOCUMENTA
@brief Es la cantidad de veces que la función seno itera.
Es inversamente proporcional a la velocidad.

Como `Seno(x)` utiliza series de Taylor para calcular el seno, este determina
cuantas veces se tendra que iterar, un numero mayor o igual a cinco (5) ya
se vuelve lento. Si se requiere una alta precisión, puede seleccionar
un numero alto, como 7 o 9, pero esto es a costa de la velocidad. Si por
el contrario, se requiere una precisión promedio, puede dejarlo en su
valor predeterminado o en 5. Recuerde que este numero tambien es utilizado
por `Coseno(x)` y `Tangente(x)`, y la función `Tangente(x)` dura el doble
que las otras dos, por lo que un numero muy elevado para calcular tangentes
es altamente ineficiente.
DOCUMENTA]
adquirir ITERACIONES_DE_SENO
fijar ITERACIONES_DE_SENO a {5}

[DOCUMENTA
@brief Determina si dos decimales son aproximadamente iguales.
Nunca de debe comparar decimales con `son iguales` o
`comparar Importar.Dec.Comparar`, esto puede ocasionar fallas poco esperadas.

Utiliza DELTA

@arg dec1 Decimal número 1 a comparar
@arg dec2 Decimal número 2 a comparar

@dev Si son aproximadamente iguales.

@races None
DOCUMENTA]
funcion SonIguales de dec1 y dec2
	adquirir resta
	Importar.Dec.Restar dec1 dec2 resta
	si comparar Importar.Dec.Comparar resta < CERO
		Importar.Dec.Restar CERO resta resta
	fin
	si comparar Importar.Dec.Comparar resta < DELTA
		devolver VERDADERO
	sino
		devolver FALSO
	fin
	liberar resta
finfun

[DOCUMENTA
@brief Suma dos numeros.
Si los numeros son enteros, aplica la suma entera, en otro caso aplica
la suma decimal.

Determina si son enteros o no buscando un separador decimal ("," o ".") en
los numeros.

@arg lvalue Valor izquierdo a sumar.
@arg rvalue Valor derecho a sumar.

@dev Decimal resultado de la suma.

@races None
DOCUMENTA]
funcion Sumar de lv y rv
	adquirir sr
	adquirir decimal
	fijar decimal a FALSO
	si son diferentes llamar Cadena#Buscar lv {.} finargs y CMMERROR
		fijar decimal a VERDADERO
	sino
		si son diferentes llamar Cadena#Buscar rv {.} finargs y CMMERROR
			fijar decimal a VERDADERO
		fin
	fin
	si decimal
		Importar.Dec.Sumar lv rv sr
	sino
		Importar.Ent.Sumar lv rv sr
	fin
	devolver sr
	liberar sr
	liberar decimal
finfun

[DOCUMENTA
@brief Resta dos numeros.
Si los numeros son enteros, aplica la resta entera, en otro caso aplica
la resta decimal.

Determina si son enteros o no buscando un separador decimal ("," o ".") en
los numeros.

@arg lvalue Valor izquierdo a restar.
@arg rvalue Valor derecho a restar.

@dev Decimal resultado de la resta.

@races None
DOCUMENTA]
funcion Restar de lv y rv
	adquirir sr
	adquirir decimal
	fijar decimal a FALSO
	si son diferentes llamar Cadena#Buscar lv {.} finargs y CMMERROR
		fijar decimal a VERDADERO
	sino
		si son diferentes llamar Cadena#Buscar rv {.} finargs y CMMERROR
			fijar decimal a VERDADERO
		fin
	fin
	si decimal
		Importar.Dec.Restar lv rv sr
	sino
		Importar.Ent.Restar lv rv sr
	fin
	devolver sr
	liberar sr
	liberar decimal
finfun

[DOCUMENTA
@brief Multiplica dos numeros.
Si los numeros son enteros, aplica la multiplicación entera, en otro caso aplica
la multiplicación decimal.

Determina si son enteros o no buscando un separador decimal ("," o ".") en
los numeros.

@arg lvalue Valor izquierdo a multiplicar.
@arg rvalue Valor derecho a multiplicar.

@dev Decimal resultado de la multiplicación.

@races None
DOCUMENTA]
funcion Multiplicar de lv y rv
	adquirir sr
	adquirir decimal
	fijar decimal a FALSO
	si son diferentes llamar Cadena#Buscar lv {.} finargs y CMMERROR
		fijar decimal a VERDADERO
	sino
		si son diferentes llamar Cadena#Buscar rv {.} finargs y CMMERROR
			fijar decimal a VERDADERO
		fin
	fin
	si decimal
		Importar.Dec.Multiplicar lv rv sr
	sino
		Importar.Ent.Multiplicar lv rv sr
	fin
	devolver sr
	liberar sr
	liberar decimal
finfun

[DOCUMENTA
@brief Divide dos numeros.
Si los numeros son enteros, aplica la división entera, en otro caso aplica
la división decimal.

Determina si son enteros o no buscando un separador decimal ("," o ".") en
los numeros.

@arg lvalue Valor izquierdo a dividir.
@arg rvalue Valor derecho a dividir.

@dev Decimal resultado de la división.

@races None
DOCUMENTA]
funcion Dividir de lv y rv
	adquirir sr
	adquirir decimal
	fijar decimal a FALSO
	si son diferentes llamar Cadena#Buscar lv {.} finargs y CMMERROR
		fijar decimal a VERDADERO
	sino
		si son diferentes llamar Cadena#Buscar rv {.} finargs y CMMERROR
			fijar decimal a VERDADERO
		fin
	fin
	si decimal
		Importar.Dec.Dividir lv rv sr
	sino
		Importar.Ent.Dividir lv rv sr
	fin
	devolver sr
	liberar sr
	liberar decimal
finfun

[DOCUMENTA
@brief Calcula el valor de una base elevado a un exponente.
Se asume que la base es decimal más el exponente es entero.

@arg base Base de la potencia
@arg exponente Exponente de la potencia

@dev El resultado de `base^exponente`.

@races None
DOCUMENTA]
funcion ElevarValor de base y exponente
	si son iguales exponente y CERO
		devolver UNO
	sino
		adquirir resultado
		adquirir acumulador
		adquirir cuenta
		fijar cuenta a UNO
		fijar acumulador a base
		mientras comparar Importar.Ent.Comparar cuenta < exponente
			Importar.Dec.Multiplicar acumulador base acumulador
			Importar.Ent.Sumar cuenta UNO cuenta
		finbucle
		devolver acumulador
		liberar cuenta
		liberar acumulador
		liberar resultado
	fin
finfun

[DOCUMENTA
@brief Calcula el factorial de un numero n.
Si `n < 0`,  devuelve 1 al igual que si `n == 0` o 1.

@arg n Numero a calcular el factorial.

@dev El factorial de dicho numero, o 1.

@races None
DOCUMENTA]
funcion Factorial de numero
	adquirir factorial
	fijar factorial a numero
	si comparar Importar.Dec.Comparar numero <= UNO
		fijar factorial a UNO
	fin
	mientras comparar Importar.Dec.Comparar numero > UNO
		Importar.Dec.Restar numero UNO numero
		Importar.Dec.Multiplicar factorial numero factorial
	finbucle
	devolver factorial
	liberar factorial
finfun

[DOCUMENTA
@brief Convierte grados sexadecimales a radianes.

@arg grados Grados a convertir

@dev El valor en Radianes

@races None
DOCUMENTA]
funcion GradosARadianes de grados
	adquirir radianes
	adquirir divisor
	Importar.Dec.Multiplicar grados PI grados
	fijar divisor a {180}
	Importar.Dec.Dividir grados divisor radianes
	devolver radianes
	liberar grados
	liberar divisor
finfun

[DOCUMENTA
@brief Convierte radianes a grados sexadecimales.

@arg radianes Valor en radianes a convertir

@dev El valor en Grados sexadecimales

@races None
DOCUMENTA]
funcion RadianesAGrados de radianes
	adquirir grados
	adquirir divisor
	fijar divisor a {180}
	Importar.Dec.Multiplicar radianes divisor radianes
	Importar.Dec.Dividir radianes PI grados
	devolver grados
	liberar grados
	liberar divisor
finfun

[DOCUMENTA
@brief Calcula el valor absoluto de un numero.
El valor absoluto de un numero x, es `|x|` y se define
como `{x Si x >= 0} o {-x Si < 0}`, es decir, siempre es
positivo.

@arg val Valor a calcular el valor absoluto.

@dev El valor absoluto de val.

@races None
DOCUMENTA]
funcion ValorAbsoluto de valor
	si comparar Importar.Dec.Comparar valor < CERO
		Importar.Dec.Restar CERO valor valor
	fin
	devolver valor
finfun

funcion __Seno de angulo y num_iteraciones
	[ *****************************************************************
	* Calcula el seno de un angulo utilizando el polinomio de
	* MacLaurin (Series de Taylor).
	*
	* Solo calcula el seno de un número entre 0 y PI/2.
	***************************************************************** ]
	adquirir n
	adquirir 2n+1
	adquirir seno
	adquirir v
	fijar n a {0}
	fijar seno a {0.0}
	fijar 2n+1 a {0.0}
	fijar v a {0.0}

	mientras comparar Importar.Ent.Comparar n < num_iteraciones
		fijar 2n+1 a
			llamar Sumar
				llamar Multiplicar {2.0} n finargs
				{1.0}
			finargs
		fijar v a
			llamar Dividir
				llamar ElevarValor
					{-1.0}
					n
				finargs
				llamar Factorial 2n+1 finargs
			finargs

		fijar seno a
			llamar Sumar
				seno
				llamar Multiplicar
					llamar ElevarValor
						angulo
						2n+1
					finargs
					v
				finargs
			finargs

		Importar.Ent.Sumar n UNO n
	finbucle

	devolver seno

	liberar n
	liberar seno
	liberar 2n+1
	liberar v
finfun

[DOCUMENTA
@brief Calcula el seno trigonométrico de un angulo.
El seno de un número siempre estará entre 0 y 1 (inclusive ambos)
y es una onda periodica en 2PI con las propiedades:

 * `sen(0) = 0`
 * `sen(PI) = 0`
 * `sen(k * PI) = 0`
 * `sen(PI / 2) = 1`
 * `sen(x) = -sen(-x)`

@arg angulo Angulo cuyo seno va a ser calculado

@dev El seno trigonométrico de dicho angulo

@races None
DOCUMENTA]
funcion Seno de angulo
	[ *************************************************
	* Similar a __Seno pero disminuye el angulo a
	* un número entre 0 y PI/2 antes de ejecutarse.
	************************************************* ]

	adquirir PI/2
	adquirir 2PI
	adquirir mp
	adquirir rs

	fijar PI/2 a {0}
	fijar 2PI a {0}
	fijar mp a {1}
	Importar.Dec.Dividir PI DOS PI/2
	Importar.Dec.Multiplicar PI DOS 2PI

	si comparar Importar.Dec.Comparar angulo < CERO
		Importar.Dec.Restar CERO angulo angulo
		fijar mp a {-1}
	fin

	mientras comparar Importar.Dec.Comparar angulo > 2PI
		Importar.Dec.Restar angulo 2PI angulo
	finbucle

	si comparar Importar.Dec.Comparar angulo > PI
		Importar.Ent.Multiplicar mp UNON mp
		Importar.Dec.Restar angulo PI angulo
	fin

	si comparar Importar.Dec.Comparar angulo > PI/2
		Importar.Dec.Restar PI angulo angulo
	fin

	fijar rs a llamar __Seno angulo ITERACIONES_DE_SENO finargs

	Importar.Dec.Multiplicar rs mp rs

	devolver rs

	liberar PI/2
	liberar 2PI
	liberar mp
	liberar rs
finfun

[DOCUMENTA
@brief Calcula el coseno de un angulo.

Realmente llama a `Seno((PI/2) - ang)`, lo cual es equivalente.

@arg ang Angulo en radianes.

@dev El coseno del angulo.

@races <Seno>
DOCUMENTA]
funcion Coseno de angulo
	adquirir defase
	fijar defase =¿? PI
	Importar.Dec.Dividir defase DOS defase
	Importar.Dec.Restar defase angulo angulo
	devolver llamar Seno angulo finargs
	liberar defase
finfun

[DOCUMENTA
@brief Calcula la raiz cuadrada de un numero.
Utiliza el metodo babilonico para calcular la raiz cuadrada de un numero.

@arg area Numero a radicar.

@dev Decimal resultado de la radicacion.

@races None
DOCUMENTA]
funcion RaizCuadrada de area
	adquirir base
	adquirir altura
	fijar base a {0.5}
	fijar altura a RAIZ_CUADRADA_MIN
	mientras no llamar SonIguales base altura finargs
		fijar base a llamar Dividir
			llamar Sumar
				base
				altura
			finargs
			{2}
		finargs
		fijar altura a llamar Dividir
			area
			base
		finargs
	finbucle
	devolver base
	liberar altura
	liberar base
finfun

[DOCUMENTA
@brief Calcula el piso de un numero.
El piso de X, es el numero entero menor o igual más cercano a X.

Por ejemplo: `piso(3.232) = 3`, `piso(3.99999) = 3`, `piso(8) = 8`.

@arg valor Numero a calcular el piso.

@dev El piso de `valor`.

@races None
DOCUMENTA]
funcion Piso de valor
	Importar.Ent.Sumar valor CERO valor [ La suma de enteros redondea a cero ]
	devolver valor
finfun

[DOCUMENTA
@brief Calcula el techo de un numero.
El techo de X, es el numero entero mayor o igual más cercano a X.
Por ejemplo: `techo(3.232) = 4`, `techo(3.99999) = 4`, `techo(8) = 8`.
@arg nm Numero a calcular el techo.
@dev El techo de nm.
@races None
DOCUMENTA]
funcion Techo de valor
	adquirir techo
	Importar.Ent.Sumar valor CERO techo
	si comparar Importar.Dec.Comparar valor = techo [ "son iguales" podria fallar por precisión ]
		devolver techo
	sino
		Importar.Ent.Sumar techo UNO techo
		devolver techo
	fin
	liberar techo
finfun

[DOCUMENTA
@brief Es una division
Posee todos los datos de una division.

Con este se puede calcular el resto y cociente de una division.

@obsolete
DOCUMENTA]
clase Division hereda Objeto
	atributo resto
	atributo cociente

	metodo divide
finclase

[DOCUMENTA
@brief Divide dos numeros.
Los datos de la division son almacenados en la instancia actual.

De ser el divisor cero, no realizara accion.

@argyo
@arg dividendo Numero a dividir.
@arg divisor Numero que dividira

@races None
DOCUMENTA]
funcion Division#divide [ yo, a, b :: yo.cociente = a/b yo.resto = a % b ]
	instancia Referencia __Division_divide_yo__
	adquirir __Division_divide_a__
	adquirir __Division_divide_b__
	adquirir __Division_divide_coc__
	adquirir __Division_divide_res__
	adquirir __Division_divide_mt__
	recibir_parametro __Division_divide_yo__#ref
	recibir_parametro __Division_divide_a__
	recibir_parametro __Division_divide_b__
	si comparar Importar.Ent.Comparar __Division_divide_b__ != CERO
		Importar.Ent.Dividir __Division_divide_a__ __Division_divide_b__ __Division_divide_coc__
		fijar __Division_divide_mt__ =* cociente
		llamar __Division_divide_yo__#fijarAttr __Division_divide_mt__ __Division_divide_coc__ #(Final).
		Importar.Ent.Restar CERO __Division_divide_b__ __Division_divide_res__
		Importar.Ent.Multiplicar __Division_divide_res__ __Division_divide_coc__ __Division_divide_res__
		Importar.Ent.Sumar __Division_divide_res__ __Division_divide_a__ __Division_divide_res__
		fijar __Division_divide_mt__ =* resto
		llamar __Division_divide_yo__#fijarAttr __Division_divide_mt__ __Division_divide_res__ #(Final).
	fin
	liberar __Division_divide_yo__
	liberar __Division_divide_a__
	liberar __Division_divide_b__
	liberar __Division_divide_coc__
	liberar __Division_divide_res__
	liberar __Division_divide_mt__
finfun
