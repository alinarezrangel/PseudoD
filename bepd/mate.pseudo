[ ******************************************************************************
*****************************************
*********
** mate.pseudo: Funciones matematicas de PseudoD
** Declara funciones matemáticas.
** PseudoD fue creado por Alejandro Linarez Rangel
** mate.pseudo fue creado por Alejandro Linarez Rangel
** Puede copiar, redistribuir y modificar este archivo con permiso de
** <proyectopseudod@gmail.com>.
*****************************************
****************************************************************************** ]

utilizar inic.pseudo
utilizar tipos.pseudo

[DOCUMENTA
@file Documentación de mate.pseudo.
Esta es la biblioteca matemática de PseudoD, aqui estan todas las
funciones matemáticas de PseudoD implementadas en PseudoD.
DOCUMENTA]

[DOCUMENTA
@brief Valor PI.
Es el valor 3.14159...
DOCUMENTA]
adquirir PI
fijar PI =* 3.141595

[DOCUMENTA
@brief Constante de Napier.
Es el valor 2.718281...
DOCUMENTA]
adquirir E
fijar E =* 2.718281

[DOCUMENTA
@brief Valor para comparar decimales.
Es aproximadamente 0.000005.
DOCUMENTA]
adquirir DELTA
fijar DELTA =* 0.000005

[DOCUMENTA
@brief Mayor cantidad de decimales que puede almacenar un numero.
Es el limite visualizable de <code class="cpp">long double</code>,(para numeros
mayores, se visualizaran con notacion cientifica).
DOCUMENTA]
adquirir PRECISION_DECIMAL
fijar PRECISION_DECIMAL =* 6

[DOCUMENTA
@brief Es el punto de inicio de la funcion RaizCuadrada.
A menor valor, mayor es la precicion de la funcion pero es mas lenta.
DOCUMENTA]
adquirir RAIZ_CUADRADA_MIN
fijar RAIZ_CUADRADA_MIN =* 0.0001

[DOCUMENTA
@brief Es un valor que no es un numero.
Representa valores indeterminados, como una division entre cero.
DOCUMENTA]
adquirir NO_ES_NUMERO
fijar NO_ES_NUMERO =* **(No es un numero)**

[DOCUMENTA
@brief Es la cantidad de veces que la función seno itera.
Es inversamente proporcional a la velocidad.
@pbreak
Como Seno(x) utiliza series de Taylor para calcular el seno, este determina
cuantas veces se tendra que iterar, un numero mayor o igual a cinco(5) ya
se vuelve lento. Si se requiere una alta precisión, puede seleccionar
un numero alto, como 7 o 9, pero esto es a costa de la velocidad. Si por
el contrario, se requiere una precisión promedio, puede dejarlo en su
valor predeterminado o en 5. Recuerde que este numero tambien es utilizado
por Coseno(x) y Tangente(x), y la función Tangente(x) dura el doble
que las otras dos, por lo que un numero muy elevado para calcular tangentes
es altamente ineficiente.
DOCUMENTA]
adquirir ITERACIONES_DE_SENO
fijar ITERACIONES_DE_SENO =* 5

[DOCUMENTA
@brief Calcula el valor de una base elevado a un exponente.
@arg base Base de la potencia
@arg exponente Exponente de la potencia
@dev El resultado de base^exponente.
@errors Active
DOCUMENTA]
funcion Elevar_valor [ base,expo ]
	adquirir __Elevar_valor_base__
	adquirir __Elevar_valor_exponente__
	adquirir __Elevar_valor_resultado__
	adquirir __Elevar_valor_acum__
	adquirir __Elevar_valor_cuenta__
	recibir_parametro __Elevar_valor_base__
	recibir_parametro __Elevar_valor_exponente__
	fijar __Elevar_valor_cuenta__ =¿? UNO
	fijar __Elevar_valor_acum__ =¿? __Elevar_valor_base__
	mientras comparar Importar.Ent.Comparar __Elevar_valor_cuenta__ < __Elevar_valor_exponente__
		Importar.Dec.Multiplicar __Elevar_valor_acum__ __Elevar_valor_base__ __Elevar_valor_acum__
		Importar.Ent.Sumar __Elevar_valor_cuenta__ UNO __Elevar_valor_cuenta__
	finbucle
	devolver __Elevar_valor_acum__
	liberar __Elevar_valor_cuenta__
	liberar __Elevar_valor_acum__
	liberar __Elevar_valor_resultado__
	liberar __Elevar_valor_exponente__
	liberar __Elevar_valor_base__
finfun

[DOCUMENTA
@brief Calcula el factorial de un numero n.
Si n < 0,  devuelve 1 al igual que si n == 0 o 1.
@arg n Numero a calcular el factorial.
@dev El factorial de dicho numero, o 1.
@errors Active
DOCUMENTA]
funcion Factorial
	adquirir __¿MAYOR_A_CERO?__
	adquirir __NUMERO_N__
	adquirir __CUENTA__
	recibir_parametro __NUMERO_N__
	fijar __CUENTA__ =¿? __NUMERO_N__
	Importar.Ent.Comparar __NUMERO_N__ > UNO __¿MAYOR_A_CERO?__
	si_no __¿MAYOR_A_CERO?__
		fijar __CUENTA__ =¿? UNO
	fin
	mientras __¿MAYOR_A_CERO?__
		Importar.Dec.Restar __NUMERO_N__ UNO __NUMERO_N__
		Importar.Dec.Multiplicar __CUENTA__ __NUMERO_N__ __CUENTA__
		Importar.Dec.Comparar __NUMERO_N__ > UNO __¿MAYOR_A_CERO?__
	finbucle
	devolver __CUENTA__
	liberar __¿MAYOR_A_CERO?__
	liberar __NUMERO_N__
	liberar __CUENTA__
finfun

[DOCUMENTA
@brief Convierte grados sexadecimales a radianes.
@arg grados Grados a convertir
@dev El valor en Radianes
@errors Active
DOCUMENTA]
funcion Grados_A_Radianes
	adquirir __GRADOS__
	adquirir __RADIANES__
	adquirir __DIVIDE__
	recibir_parametro __GRADOS__
	Importar.Dec.Multiplicar __GRADOS__ PI __GRADOS__
	fijar __DIVIDE__ =* 180
	Importar.Dec.Dividir __GRADOS__ __DIVIDE__ __RADIANES__
	devolver __RADIANES__
	liberar __GRADOS__
	liberar __RADIANES__
	liberar __DIVIDE__
finfun

[DOCUMENTA
@brief Convierte radianes a grados sexadecimales.
@arg radianes Valor en radianes a convertir
@dev El valor en Grados sexadecimales
@errors Active
DOCUMENTA]
funcion Radianes_A_Grados
	adquirir __GRADOS__
	adquirir __RADIANES__
	adquirir __DIVIDE__
	recibir_parametro __GRADOS__
	fijar __DIVIDE__ =* 180
	Importar.Dec.Multiplicar __GRADOS__ __DIVIDE__ __GRADOS__
	Importar.Dec.Dividir __GRADOS__ PI __RADIANES__
	devolver __RADIANES__
	liberar __GRADOS__
	liberar __RADIANES__
	liberar __DIVIDE__
finfun

[DOCUMENTA
@brief Calcula el valor absoluto de un numero.
El valor absoluto de un numero x, es |x| y se define
como {x Si x >= 0} o {-x Si < 0}, es decir, siempre es
positivo.
@arg val Valor a calcular el valor absoluto.
@dev El valor absoluto de val.
@errors Active
DOCUMENTA]
funcion Valor_absoluto [ val ]
	adquirir __Valor_absoluto_val__
	recibir_parametro __Valor_absoluto_val__
	si comparar Importar.Dec.Comparar __Valor_absoluto_val__ < CERO
		Importar.Dec.Restar CERO __Valor_absoluto_val__ __Valor_absoluto_val__
	fin
	devolver __Valor_absoluto_val__
	liberar __Valor_absoluto_val__
finfun

[DOCUMENTA
@brief Ajusta un numero decimal para el seno/coseno.
Simplemente lo reduce al rango [0-PI).
@arg ang Angulo a ajustar.
@dev Angulo ajustado.
@errors Active
DOCUMENTA]
funcion Ajustar_para_seno [ ang ]
	adquirir __Ajustar_pseno_ang__
	adquirir __Ajustar_pseno_per__
	recibir_parametro __Ajustar_pseno_ang__
	fijar __Ajustar_pseno_per__ =¿? PI
	Importar.Dec.Multiplicar __Ajustar_pseno_per__ DOS __Ajustar_pseno_per__
	si comparar Importar.Dec.Comparar __Ajustar_pseno_ang__ < CERO
		llamar Valor_absoluto __Ajustar_pseno_ang__ #(Final).
		recibir_resultado __Ajustar_pseno_ang__
	fin
	mientras comparar Importar.Dec.Comparar __Ajustar_pseno_ang__ >= __Ajustar_pseno_per__
		Importar.Dec.Restar __Ajustar_pseno_ang__ __Ajustar_pseno_per__ __Ajustar_pseno_ang__
	finbucle
	devolver __Ajustar_pseno_ang__
	liberar __Ajustar_pseno_ang__
	liberar __Ajustar_pseno_per__
finfun

[DOCUMENTA
@brief Calcula el seno de un angulo.
@arg ang Angulo en radianes.
@dev Decimal resultado del seno.
@errors Active
DOCUMENTA]
funcion Seno [ ang ]
	[ **********************************************
		Breve explicación del algoritmo:
		Podemos definir el seno de x como:
			sin(x) = SUM(0 -> inf,n){((-1)^n)((x^(2n+1))/((2n+1)!))}
		Por lo tanto, si x esta en el rango 0 <= x <= PI
		entonces las iteraciones son minimas.
		La funcion Seno primero llama a Ajustar_para_seno,
		el cual ajusta un numero hasta el rango 0 <= x <= PI.
		.
		La implementación no es muy compleja debido a
		que ya existen las funciones Elevar_valor y
		Factorial.
		.
		Solo necesitamos la parte positiva dado que
			sin(-x) = -sin(x)
			sin(x) = -sin(-x)
		Coseno utiliza esta función por la igualdad:
			cos(x) = sin((PI/2) - x)
	********************************************** ]
	adquirir __Seno_ang__
	adquirir __Seno_rang__
	adquirir __Seno_cuenta__
	adquirir __Seno_hasta__
	adquirir __Seno_resultado__
	adquirir __Seno_va__
	adquirir __Seno_vb__
	adquirir __Seno_vc__
	adquirir __Seno_op__
	recibir_parametro __Seno_ang__
	fijar __Seno_rang__ =¿? __Seno_ang__
	llamar Ajustar_para_seno __Seno_ang__ #(Final).
	recibir_resultado __Seno_ang__
	fijar __Seno_cuenta__ =* 0
	fijar __Seno_hasta__ =¿? ITERACIONES_DE_SENO
	fijar __Seno_resultado__ =* 0.0
	fijar __Seno_va__ =* 0
	fijar __Seno_vb__ =* 0
	fijar __Seno_vc__ =* 0
	fijar __Seno_op__ =¿? VERDADERO
	mientras comparar Importar.Ent.Comparar __Seno_cuenta__ < __Seno_hasta__
		Importar.Dec.Multiplicar DOS __Seno_cuenta__ __Seno_va__
		Importar.Dec.Sumar UNO __Seno_va__ __Seno_va__
		fijar __Seno_vb__ =¿? __Seno_va__
		llamar Elevar_valor __Seno_ang__ __Seno_va__ #(Final).
		recibir_resultado __Seno_va__
		llamar Factorial __Seno_vb__ #(Final).
		recibir_resultado __Seno_vb__
		Importar.Dec.Dividir __Seno_va__ __Seno_vb__ __Seno_va__
		si __Seno_op__
			Importar.Dec.Sumar __Seno_resultado__ __Seno_va__ __Seno_resultado__
			fijar __Seno_op__ =¿? FALSO
		sino
			Importar.Dec.Restar __Seno_resultado__ __Seno_va__ __Seno_resultado__
			fijar __Seno_op__ =¿? VERDADERO
		fin
		Importar.Ent.Sumar __Seno_cuenta__ UNO __Seno_cuenta__
	finbucle
	si comparar Importar.Dec.Comparar __Seno_rang__ < CERO
		Importar.Dec.Restar CERO __Seno_resultado__ __Seno_resultado__
	fin
	devolver __Seno_resultado__
	liberar __Seno_cuenta__
	liberar __Seno_hasta__
	liberar __Seno_ang__
	liberar __Seno_rang__
	liberar __Seno_resultado__
	liberar __Seno_va__
	liberar __Seno_vb__
	liberar __Seno_vc__
	liberar __Seno_op__
finfun

[DOCUMENTA
@brief Calcula el coseno de un angulo.
Realmente llama a Seno((PI/2) - ang), lo cual es equivalente.
@arg ang Angulo en radianes.
@dev El coseno del angulo.
@errors Active
DOCUMENTA]
funcion Coseno [ ang ]
	adquirir __Coseno_ang__
	adquirir __Coseno_def__
	recibir_parametro __Coseno_ang__
	fijar __Coseno_def__ =¿? PI
	Importar.Dec.Dividir __Coseno_def__ DOS __Coseno_def__
	Importar.Dec.Restar __Coseno_def__ __Coseno_ang__ __Coseno_ang__
	llamar Seno __Coseno_ang__ #(Final).
	liberar __Coseno_def__
	liberar __Coseno_ang__
finfun

[DOCUMENTA
@brief Calcula la raiz cuadrada de un numero.
utiliza el metodo babilonico para calcular la raiz cuadrada de un numero.
@arg nm Numero a radicar.
@dev Decimal resultado de la radicacion.
@errors Active
DOCUMENTA]
funcion Raiz_cuadrada [ nm -> sqrt(nm) ]
	adquirir __raizcuadrada_a__
	adquirir __raizcuadrada_an__
	adquirir __raizcuadrada_anu__
	adquirir __raizcuadrada_cpc__
	adquirir __raizcuadrada_buf__
	recibir_parametro __raizcuadrada_a__
	fijar __raizcuadrada_cpc__ =* 0.5
	fijar __raizcuadrada_anu__ =¿? RAIZ_CUADRADA_MIN
	fijar __raizcuadrada_an__ =* 0
	mientras no ¿son_iguales? __raizcuadrada_an__ __raizcuadrada_anu__
		fijar __raizcuadrada_an__ =¿? __raizcuadrada_anu__
		Importar.Dec.Dividir __raizcuadrada_a__ __raizcuadrada_an__ __raizcuadrada_buf__
		Importar.Dec.Sumar __raizcuadrada_buf__ __raizcuadrada_an__ __raizcuadrada_buf__
		Importar.Dec.Multiplicar __raizcuadrada_buf__ __raizcuadrada_cpc__ __raizcuadrada_anu__
	finbucle
	devolver __raizcuadrada_an__
	liberar __raizcuadrada_a__
	liberar __raizcuadrada_an__
	liberar __raizcuadrada_anu__
	liberar __raizcuadrada_cpc__
	liberar __raizcuadrada_buf__
finfun

[DOCUMENTA
@brief Calcula el piso de un numero.
El piso de X, es el numero entero menor o igual más cercano a X.
Por ejemplo: piso(3.232) = 3, piso(3.99999) = 3, piso(8) = 8.
@arg nm Numero a calcular el piso.
@dev El piso de nm.
@errors Active
DOCUMENTA]
funcion Piso [ nm -> floor(nm) ]
	adquirir __piso_val__
	recibir_parametro __piso_val__
	Importar.Ent.Sumar __piso_val__ CERO __piso_val__
	devolver __piso_val__
	liberar __piso_val__
finfun

[DOCUMENTA
@brief Calcula el techo de un numero.
El techo de X, es el numero entero mayor o igual más cercano a X.
Por ejemplo: techo(3.232) = 3, techo(3.99999) = 3, techo(8) = 8.
@arg nm Numero a calcular el techo.
@dev El techo de nm.
@errors Active
DOCUMENTA]
funcion Techo [ nm -> ceil(nm) ]
	adquirir __techo_val__
	adquirir __techo_bff__
	recibir_parametro __techo_val__
	Importar.Ent.Sumar __techo_val__ CERO __techo_bff__
	si comparar Importar.Dec.Comparar __techo_val__ = __techo_bff__
		devolver __techo_bff__
	sino
		Importar.Ent.Sumar __techo_val__ UNO __techo_val__
		devolver __techo_val__
	fin
	liberar __techo_val__
	liberar __techo_bff__
finfun

[DOCUMENTA
@brief Es una division
Posee todos los datos de una division.
Con este se puede calcular el resto y cociente de una division.
DOCUMENTA]
clase Division
	resto
	cociente
	:divide
#(Final).
heredar Objeto Division

[DOCUMENTA
@brief Divide dos numeros.
Los datos de la division son almacenados en la instancia actual.
De ser el divisor cero, no realizara accion.
@argyo
@arg dividendo Numero a dividir.
@arg divisor Numero que dividira.
@errors Active
DOCUMENTA]
funcion Division#divide [ yo, a, b :: yo.cociente = a/b yo.resto = a % b ]
	instancia Referencia __Division_divide_yo__
	adquirir __Division_divide_a__
	adquirir __Division_divide_b__
	adquirir __Division_divide_coc__
	adquirir __Division_divide_res__
	adquirir __Division_divide_mt__
	recibir_parametro __Division_divide_yo__#ref
	recibir_parametro __Division_divide_a__
	recibir_parametro __Division_divide_b__
	si comparar Importar.Ent.Comparar __Division_divide_b__ != CERO
		Importar.Ent.Dividir __Division_divide_a__ __Division_divide_b__ __Division_divide_coc__
		fijar __Division_divide_mt__ =* cociente
		llamar __Division_divide_yo__#fijarAttr __Division_divide_mt__ __Division_divide_coc__ #(Final).
		Importar.Ent.Restar CERO __Division_divide_b__ __Division_divide_res__
		Importar.Ent.Multiplicar __Division_divide_res__ __Division_divide_coc__ __Division_divide_res__
		Importar.Ent.Sumar __Division_divide_res__ __Division_divide_a__ __Division_divide_res__
		fijar __Division_divide_mt__ =* resto
		llamar __Division_divide_yo__#fijarAttr __Division_divide_mt__ __Division_divide_res__ #(Final).
	fin
	liberar __Division_divide_yo__
	liberar __Division_divide_a__
	liberar __Division_divide_b__
	liberar __Division_divide_coc__
	liberar __Division_divide_res__
	liberar __Division_divide_mt__
finfun

